import numpy as np
import datetime
import math


def run(review_ts, param, thr, eval_ts, n_pres_current, idx_ts_current):

    alpha, beta = param

    n_review_max = len(review_ts)

    n_item = 0
    n_review = 0

    list_n_pres = []

    for ts in review_ts[::-1]:

        delta = eval_ts - ts
        min_n = (math.log(-(np.log(thr))) - math.log(alpha*delta)) \
            / math.log(1 - beta) + 1
        n_pres = math.ceil(min_n)
        n_review += n_pres
        if n_review > n_review_max:
            break
        list_n_pres.append(n_pres)
        n_item += 1

    u = np.ones(len(n_pres_current))
    u[n_item:] = 0  # Items that can not be learnt should not be presented

    if n_review_max - idx_ts_current >= n_item:
        u[n_pres_current >= np.min(list_n_pres)] = 0
        return u

    print("estimation n learnt", n_item)
    print("n pres current", n_pres_current)
    print("n pres needed", list_n_pres)
    print("len n pres needed", len(list_n_pres))
    print(len(review_ts))
    # for n_pres in n_pres_current:
    #     bool_sup = n_pres_current >= n_pres
    #     still_in_track = u == 1
    #     select = bool_sup * still_in_track
    #     if np.sum(select) == 0:
    #         break
    #     else:
    #         v = np.min(n_pres_current[select])
    #         fit_cr = n_pres_current == v
    #         it = np.argmax(fit_cr)
    #         u[it] = 0
    u[n_pres_current + 1 >= np.min(list_n_pres)] = 0
    print(u)
    return u
